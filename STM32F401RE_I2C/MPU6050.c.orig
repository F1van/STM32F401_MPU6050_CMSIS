// MPU6050

#include "MPU6050.h"
volatile uint8_t DMP_packet_size;

float a_norm = 0;
float g_norm = 0;

//=============================================================================
// Чтение адреса MPU из регистра WHO_AM_I
uint8_t read_MPU_ID(void)
{
	uint8_t status = 1;
	uint8_t MPU_ID = I2C_read_reg(I2C1, MPU6050_addr, WHO_AM_I);
	// установка курсора в начало 1-й строки
	LCD_pos(1, 1);
	if (MPU_ID == 0x68) LCD_send_string("MPU6050.......OK");
	else if (MPU_ID == 0x71) 
	{
		LCD_send_string("MPU9250.......OK");
		status = 0;
	}
	else 
	{
		LCD_send_string("MPU.........fail");
		status = 1;
	}
	LCD_pos(2, 1);
	LCD_send_string("          (2/10)");
	_delay_ms(2000);
	return status;
}

//=============================================================================
// сброс MPU6050, выход из режима сна, источник синхронизации: PLL with X Gyro reference
void MPU6050_reset_wakeup(void)
{
	// сброс MPU6050
	I2C_write_reg(I2C1, MPU6050_addr, PWR_MGMT_1, 1<<DEVICE_RESET);
	// пауза > 100 мс
	_delay_ms(150);
	// после сброса состояние регистра PWR_MGMT_1 = 0x40 - включен спящий режим
	// выбираем источник синхронизации: CLKSEL = 1 - PLL with X Gyro reference
	I2C_write_reg(I2C1, MPU6050_addr, PWR_MGMT_1, 1<<CLKSEL);
	// Delay 100 ms for PLL to get established on x-axis gyro;
	_delay_ms(150);
	return;
}

//=============================================================================
// Инициализация MPU6050
void MPU6050_init(void)
{
	// установка частоты дискретизации
	MPU6050_set_sample_rate();
	// установка полосы пропускания НЧ-фильра акселерометра и гироскопа
	I2C_write_reg(I2C1, MPU6050_addr, CONFIG, DLPF<<DLPF_CFG);
	// настройка чувствительности гироскопа
	MPU6050_set_gyro_scale();
	// настройка чувствительности акселерометра
	MPU6050_set_accel_scale();
	// расчёт масштабных коэффициентов
	MPU6050_get_norm(&a_norm, &g_norm);
	
	// настройка вывода прерывания
	// the logic level for the INT pin is active high;
	// the INT pin is configured as open drain;
	// the INT pin is held high until the interrupt is cleared;
	// interrupt status bits are cleared only by reading INT_STATUS
	//I2C_write_reg(I2C1, MPU6050_addr, INT_PIN_CFG, 1<<LATCH_INT_EN);
        
	// прерывания по готовности данных
	I2C_write_reg(I2C1, MPU6050_addr, INT_ENABLE, 1<<DATA_RDY_EN);	

	LCD_pos(1, 1);
	LCD_send_string("MPU init......OK");
	LCD_pos(2, 1);
	LCD_send_string("          (4/10)");
	_delay_ms(2000);
	return;
}

//=============================================================================
// Установка частоты дискретизации
// - частота дискретизации = частота дискретизации ГИРОСКОПА / (1 + SMPLRT_DIV)
// - частота дискретизации ГИРОСКОПА выбирается в CONFIG (DLPF[2:0])
void MPU6050_set_sample_rate(void)
{
	uint8_t sample_div;
	switch(DLPF)
	{
		case 0:
			if(SAMPLE_RATE > 8000) sample_div = 0;
			else if(SAMPLE_RATE < 32) sample_div = 249;
			else sample_div = 8000u / SAMPLE_RATE - 1u;			
		break;
		case 7:
			if(SAMPLE_RATE > 8000) sample_div = 0;
			else if(SAMPLE_RATE < 32) sample_div = 249;
			else sample_div = 8000u / SAMPLE_RATE - 1u;
		break;
		default:
			if(SAMPLE_RATE > 1000) sample_div = 0;
			else if(SAMPLE_RATE < 4) sample_div = 249;
			else sample_div = 1000u / SAMPLE_RATE - 1u;
	}
	I2C_write_reg(I2C1, MPU6050_addr, SMPLRT_DIV, sample_div);
}

//=============================================================================
// настройка чувствительности гироскопа
void MPU6050_set_gyro_scale(void)
{
	switch (GYRO_FS)
	{
		// GYRO_FS: ±250°/сек; ±500°/сек; ±1000°/сек; ±2000°/сек
		case 250:
		I2C_write_reg(I2C1, MPU6050_addr, GYRO_CONFIG, 0x00);
		break;
		case 500:
		I2C_write_reg(I2C1, MPU6050_addr, GYRO_CONFIG, 1<<GFS_SEL);
		break;
		case 1000:
		I2C_write_reg(I2C1, MPU6050_addr, GYRO_CONFIG, 2<<GFS_SEL);
		break;
		case 2000:
		I2C_write_reg(I2C1, MPU6050_addr, GYRO_CONFIG, 3<<GFS_SEL);
		break;
	}
	return;
}

//=============================================================================
// настройка чувствительности акселерометра
void MPU6050_set_accel_scale(void)
{
	switch (ACCEL_FS)
	{
		case 2:
		I2C_write_reg(I2C1, MPU6050_addr, ACCEL_CONFIG, 0x00);
		break;
		case 4:
		I2C_write_reg(I2C1, MPU6050_addr, ACCEL_CONFIG, 1<<AFS_SEL);
		break;
		case 8:
		I2C_write_reg(I2C1, MPU6050_addr, ACCEL_CONFIG, 2<<AFS_SEL);
		break;
		case 16:
		I2C_write_reg(I2C1, MPU6050_addr, ACCEL_CONFIG, 3<<AFS_SEL);
		break;
	}
	return;
}

//=============================================================================
// Расчёт нормирующих коэффициентов акселерометра и гироскопа
// при разрядности АЦП 16 бит имеем 65536 уровней.
void MPU6050_get_norm(float* p_a_norm, float* p_g_norm)
{
	switch (ACCEL_FS)
	{
		// ACCEL_FS: ±2g; ±4g; ±8g; ±16g
		case 2:
		*p_a_norm = 2.f / 32768.f;
		break;
		case 4:
		*p_a_norm = 4.f / 32768.f;
		break;
		case 8:
		*p_a_norm = 8.f / 32768.f;
		break;
		case 16:
		*p_a_norm = 16.f / 32768.f;
		break;
	}
	switch (GYRO_FS)
	{
		// GYRO_FS: ±250°/сек; ±500°/сек; ±1000°/сек; ±2000°/сек
		case 250:
		*p_g_norm = 250.f / 32768.f;
		break;
		case 500:
		*p_g_norm = 500.f / 32768.f;
		break;
		case 1000:
		*p_g_norm = 1000.f / 32768.f;
		break;
		case 2000:
		*p_g_norm = 2000.f / 32768.f;
		break;
	}
	return;
}

//=============================================================================
// Чтение данных датчика MPU6050
void MPU6050_read_raw(int16_t* p_ax, int16_t* p_ay, int16_t* p_az, int16_t* p_gx, int16_t* p_gy, int16_t* p_gz)
{
	uint8_t MPU6050_raw[14];
	// чтение начиная с регистра ACCEL_XOUT_H
	I2C_read_regs(I2C1, MPU6050_addr, ACCEL_XOUT_H, MPU6050_raw, 14);
	// получение 16-битных значений
	*p_ax = MPU6050_raw[0]<<8 | MPU6050_raw[1];
	*p_ay = MPU6050_raw[2]<<8 | MPU6050_raw[3];
	*p_az = MPU6050_raw[4]<<8 | MPU6050_raw[5];
//	*p_t  = MPU6050_raw[6]<<8 | MPU6050_raw[7];
	*p_gx = MPU6050_raw[8]<<8 | MPU6050_raw[9];
	*p_gy = MPU6050_raw[10]<<8 | MPU6050_raw[11];
	*p_gz = MPU6050_raw[12]<<8 | MPU6050_raw[13];
	return;
}

//=============================================================================
// Чтение данных акселерометра датчика MPU6050
void MPU6050_read_raw_acc(int16_t* p_ax, int16_t* p_ay, int16_t* p_az)
{
	I2C_start(I2C1, MPU6050_addr<<1);
	I2C_write(I2C1, ACCEL_XOUT_H);
	I2C_repeated_start(I2C1, MPU6050_addr<<1|1<<0);
	*p_ax = I2C_read_ack(I2C1)<<8 | I2C_read_ack(I2C1);
	*p_ay = I2C_read_ack(I2C1)<<8 | I2C_read_ack(I2C1);
	*p_az = I2C_read_ack(I2C1)<<8 | I2C_read_nack(I2C1);
	I2C1->CR1 |= I2C_CR1_STOP;
	return;
}

//=============================================================================
// Самотестирование MPU6050 (если не используется InvenSense MotionApps)
// should return percent deviation from factory trim values,
// +/- 14 or less deviation is a pass
void MPU6050_self_test(void)
{
	char LCD_buff[16];								// буфер для ЖК-дисплея
	uint8_t data[12];
	int32_t gAvg[3] = {0}, aAvg[3] = {0}, aSTAvg[3] = {0}, gSTAvg[3] = {0};
	uint8_t Xa_test, Ya_test, Za_test, Xg_test, Yg_test, Zg_test;
	float FT_Xa, FT_Ya, FT_Za, FT_Xg, FT_Yg, FT_Zg;
	float percent_Xa, percent_Ya, percent_Za, percent_Xg, percent_Yg, percent_Zg;
	
	// сброс регистров MPU5060 и выход из сна
	MPU6050_reset_wakeup();
	
	// ФНЧ = 2 (полоса пропускания гироскопа 98 Гц, дискретизация 1 кГц)
	I2C_write_reg(I2C1, MPU6050_addr, CONFIG, 2<<DLPF_CFG);
        
	// configure the accelerometer for self-test
	// When performing accelerometer self test, the full-scale range should be set to ±8g
	I2C_write_reg(I2C1, MPU6050_addr, ACCEL_CONFIG, 2<<AFS_SEL);
        
	// configure the gyroscope for self-test
	// When performing self test for the gyroscope, the full-scale range should be set to ±250dps.
	I2C_write_reg(I2C1, MPU6050_addr, GYRO_CONFIG, 0x00);
	// delay a while to let the device stabilyze
	_delay_ms(25);

	// get average values of gyro and accelerometer output without self-test 
	// (1kHz rate, 200 readings)
	for(uint8_t i = 0; i < 200; i++) 
	{
		if((I2C_read_reg(I2C1, MPU6050_addr, INT_STATUS) & 0x01) == 0);
		I2C_read_regs(I2C1, MPU6050_addr, ACCEL_XOUT_H, data, 6);
		I2C_read_regs(I2C1, MPU6050_addr, GYRO_XOUT_H, data+6, 6);
		aAvg[0] += (int16_t)(data[0]<<8 | data[1]); 
		aAvg[1] += (int16_t)(data[2]<<8 | data[3]);
		aAvg[2] += (int16_t)(data[4]<<8 | data[5]);
		gAvg[0] += (int16_t)(data[6]<<8 | data[7]);
		gAvg[1] += (int16_t)(data[8]<<8 | data[9]);
		gAvg[2] += (int16_t)(data[10]<<8 | data[11]);
	}
	for (uint8_t i = 0; i < 3; i++) 
	{ 
		// Get average of 200 values and store as average current readings
		aAvg[i] /= 200;
		gAvg[i] /= 200;
	}

	// configure the accelerometer for self-test
	// When performing accelerometer self test, the full-scale range should be set to ±8g
	I2C_write_reg(I2C1, MPU6050_addr, ACCEL_CONFIG, 1<<XA_ST|1<<YA_ST|1<<ZA_ST|2<<AFS_SEL);
        
	// configure the gyroscope for self-test
	// When performing self test for the gyroscope, the full-scale range should be set to ±250dps.
	I2C_write_reg(I2C1, MPU6050_addr, GYRO_CONFIG, 1<<XG_ST|1<<YG_ST|1<<ZG_ST);
	// delay a while to let the device stabilyze
	_delay_ms(25);
	
	// get average values of gyro and accelerometer self-test output
	// (1kHz rate, 200 readings)
	for(uint8_t i = 0; i < 200; i++)
	{
		if((I2C_read_reg(I2C1, MPU6050_addr, INT_STATUS) & 0x01) == 0);
		I2C_read_regs(I2C1, MPU6050_addr, ACCEL_XOUT_H, data, 6);
		I2C_read_regs(I2C1, MPU6050_addr, GYRO_XOUT_H, data+6, 6);
		aSTAvg[0] += (int16_t)(data[0]<<8 | data[1]);
		aSTAvg[1] += (int16_t)(data[2]<<8 | data[3]);
		aSTAvg[2] += (int16_t)(data[4]<<8 | data[5]);
		gSTAvg[0] += (int16_t)(data[6]<<8 | data[7]);
		gSTAvg[1] += (int16_t)(data[8]<<8 | data[9]);
		gSTAvg[2] += (int16_t)(data[10]<<8 | data[11]);
	}
	for (uint8_t i = 0; i < 3; i++)
	{
		// Get average of 200 values and store as average current readings
		aSTAvg[i] /= 200L;
		gSTAvg[i] /= 200L;
	}	
	
	// чтение начиная с регистра SELF_TEST_X
	// data[0] - X-axis self-test results
	// data[1] - Y-axis self-test results
	// data[2] - Z-axis self-test results
	// data[3] - mixed-axis self-test results
	I2C_read_regs(I2C1, MPU6050_addr, SELF_TEST_X, data, 4);

	// extract the acceleration test results first
	Xa_test = (data[0] & 0xE0)>>3|(data[3] & 0x30)>>4;				// XA_TEST result is a five-bit unsigned integer
	Ya_test = (data[1] & 0xE0)>>3|(data[3] & 0x0C)>>2;				// YA_TEST result is a five-bit unsigned integer
	Za_test = (data[2] & 0xE0)>>3|(data[3] & 0x03)>>0;				// ZA_TEST result is a five-bit unsigned integer

	// extract the gyration test results first
	Xg_test = data[0] & 0x1F;										// XG_TEST result is a five-bit unsigned integer
	Yg_test = data[1] & 0x1F;										// YG_TEST result is a five-bit unsigned integer
	Zg_test = data[2] & 0x1F;										// ZG_TEST result is a five-bit unsigned integer

	// obtaining the accelerometer and gyroscope Factory Trim (FT) value
	FT_Xa = 4096.f * 0.34f * powf((0.92f / 0.34f), ((Xa_test - 1.f) / 30.f));	// FT[Xa] factory trim calculation
	FT_Ya = 4096.f * 0.34f * powf((0.92f / 0.34f), ((Ya_test - 1.f) / 30.f));	// FT[Ya] factory trim calculation
	FT_Za = 4096.f * 0.34f * powf((0.92f / 0.34f), ((Za_test - 1.f) / 30.f));	// FT[Za] factory trim calculation
	FT_Xg =  25.0f * 131.f * powf(1.046f, (Xg_test - 1.f));						// FT[Xg] factory trim calculation
	FT_Yg = -25.0f * 131.f * powf(1.046f, (Yg_test - 1.f));						// FT[Yg] factory trim calculation
	FT_Zg =  25.0f * 131.f * powf(1.046f, (Zg_test - 1.f));						// FT[Zg] factory trim calculation
	
	// report results as a ratio of (STR-FT)/FT;
	// the change from Factory Trim of the Self-Test Response
	// to get to percent, must multiply by 100 and subtract result from 100
	percent_Xa = 100.f * (aSTAvg[0] - aAvg[0] - FT_Xa) / FT_Xa;
	percent_Ya = 100.f * (aSTAvg[1] - aAvg[1] - FT_Ya) / FT_Ya;
	percent_Za = 100.f * (aSTAvg[2] - aAvg[2] - FT_Za) / FT_Za;
	percent_Xg = 100.f * (gSTAvg[0] - gAvg[0] - FT_Xg) / FT_Xg;
	percent_Yg = 100.f * (gSTAvg[1] - gAvg[1] - FT_Yg) / FT_Yg;
	percent_Zg = 100.f * (gSTAvg[2] - gAvg[2] - FT_Zg) / FT_Zg;
	
	// вывод результата на ЖК-дисплей
	LCD_pos(1, 1);
	LCD_send_string("                ");
	LCD_pos(2, 1);
	LCD_send_string("                ");
	sprintf(LCD_buff, "%4.2f %4.2f %4.2f", percent_Xa, percent_Ya, percent_Za);
	LCD_pos(1, 1);
	LCD_send_string(LCD_buff);
	sprintf(LCD_buff, "%4.2f %4.2f %4.2f", percent_Xg, percent_Yg, percent_Zg);
	LCD_pos(2, 1);
	LCD_send_string(LCD_buff);
	_delay_ms(2000);
	return;
}

//=============================================================================
// Калибровка MPU6050 (PID)
void MPU_calibrate(void)
{
	MPU6050_reset_wakeup();
	I2C_write_reg(I2C1, MPU6050_addr, CONFIG, 1<<DLPF_CFG);
	gyro_calib(6);
	accel_calib(6);

	LCD_pos(1, 1);
	LCD_send_string("MPU calibr....OK");
	LCD_pos(2, 1);
	LCD_send_string("          (3/10)");
	_delay_ms(2000);
	return;
}

//=============================================================================
// Калибровка гироскопа
void gyro_calib(uint8_t loops) 
{
	float kP = 0.3f;
	float kI = 90.f;
	float x = (100.f - map(loops, 1.f, 5.f, 20.f, 0.f)) * 0.01f;
	kP *= x;
	kI *= x;
	//PID(0x43, kP, kI, loops);
	return;
}

//=============================================================================
// Калибровка акселерометра
void accel_calib(uint8_t loops) 
{
	float kP = 0.3f;
	float kI = 20.f;
	float x = (100.f - map(loops, 1.f, 5.f, 20.f, 0.f)) * 0.01f;
	kP *= x;
	kI *= x;
	//PID(0x3B, kP, kI, loops);
	return;
}

//=============================================================================
// Масштабирование диапазона
float map(float x, float in_min, float in_max, float out_min, float out_max)
{
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

//=============================================================================
// ПИ-регулятор
void PID(uint8_t read_addr, float kP, float kI, uint8_t loops)
{
	uint8_t data_arr[6];			// массив сырых данных датчика
	int16_t data[3];			// массив значенй по координатам									
	int16_t temp;				// регистр временного хранения
		
	float T0 = 0.001;
	float error_prev[3] = {0.f, 0.f, 0.f};
	float PI_out[3];
	uint16_t zero_bit[3];			// массив для хранения нулевых бит
	int32_t e_sum;				// суммарная ошибка
	int16_t e_sample;
	
	// читаем ID MPU
	uint8_t device_ID = I2C_read_reg(I2C1, MPU6050_addr, WHO_AM_I);
	
	// вычисляем адрес для сохранения результатов калибровки
	// - если калибруем акселерометр, адрес для чтения 0x3B (ACCEL_XOUT_H),
	//   то адрес для сохранения = 0x06 (XA_OFFSET_H) если ID < 0x70,
	//   и = 0x77, если ID >= 0x70.
	// - если калибруем гироскоп, адрес для чтения 0x43 (GYRO_XOUT_H),
	//   то адрес для сохранения = 0x13 (XG_OFFSET_H);

	// выражение y = (условие)? A:B;
	// в Си означает тернарную операцию,
	// т.е., если условие выполняется, то y = A, если нет - y = B.

	// чтение начальных значений корректирующих коэффициентов 
	uint8_t save_addr = (read_addr == 0x3B)? ((device_ID < 0x70)? 0x06:0x77):0x13;
	uint8_t shift = (save_addr == 0x77)? 3:2;
	for (uint8_t i = 0; i < 3; i++)
	{
		// читаем содержимое регистра коррекции
		I2C_read_regs(I2C1, MPU6050_addr, save_addr + shift * i, data_arr, 2);
		temp = data_arr[0]<<8 | data_arr[1];		// слово коррекции
		// получаем начальные значения 
		if(save_addr != 0x13)				// для акселерометра
		{
			zero_bit[i] = temp & 0x0001;		// сохраняем 0-й бит
			PI_out[i] = (temp >> 1) * 16.f;		// сдвигаем данные на один бит вправо
		}						// и приводим к разрешению ±2g (16-бит)
		else PI_out[i] = temp * 4.f;			// для гироскопа
	}
	
	for(uint8_t L = 0; L < loops; L++)
	{
		e_sample = 0;
		for(uint8_t c = 0; c < 100; c++)		// 100 ПИ циклов
		{
			e_sum = 0;
			// ждём готовности данных
			if((I2C_read_reg(I2C1, MPU6050_addr, INT_STATUS) & 0x01) == 0);
			// читаем текущие показания по трём координатам
			I2C_read_regs(I2C1, MPU6050_addr, read_addr, data_arr, 6);
			data[0] = data_arr[0]<<8 | data_arr[1];
			data[1] = data_arr[2]<<8 | data_arr[3];
			data[2] = data_arr[4]<<8 | data_arr[5];
			
			// расчёт i-й итерации 
			for (uint8_t i = 0; i < 3; i++)
			{
				// для Z составляющей акселерометра вычитаем 1g
				if((read_addr == 0x3B) && (i == 2)) data[i] -= 16384;
				float error = -data[i];						// ошибка: error = 0 - data[i] = - data[i]
				e_sum += abs(data[i]);						// суммарная ошибка
				// расчёт ПИ-регулятора
				PI_out[i] += error * kI * T0 + kP * error - error_prev[i] * kP;
				error_prev[i] = error;
				// вывод результата
				if(save_addr != 0x13)						// если акселерометр
				{
					temp = (int16_t)round(PI_out[i] / 16.f);		// приводим к ±16g (15 бит)
					temp = temp << 1 | zero_bit[i];				// возвращаем нулевой бит
				}
				else temp = (int16_t)round(PI_out[i] / 4.f);			// если гироскоп
				// сохраняем результат в регистр коррекции
				data_arr[0] = temp >> 8 & 0xFF;
				data_arr[1] = temp & 0xFF;
				I2C_write_regs(I2C1, MPU6050_addr, save_addr + shift * i, data_arr, 2);
			}
			if((c == 99) && e_sum > 1000) c = 0;					// error is still too great to continue
			if((e_sum * ((read_addr == 0x3B)? 0.05f:1.f)) < 5) e_sample++;	// Successfully found offsets prepare to advance
			if((e_sum < 100) && (c > 10) && (e_sample >= 10)) break;		// Advance to next Loop
			_delay_ms(1);
		}
		kP *= 0.75f;
		kI *= 0.75f;
	}
}


//=========================================================================
// Инициализация DMP MotionApp_v2
// (для получения точных результатов рекомендуется работа DMP на частоте 200 Гц)
void DMP2_init(void)
{
	// сброс выполнен при калибровке...

	// получение аппаратной версии MPU
	set_memory_bank(0x10, TRUE, TRUE);				// Selecting user bank 16
	// set start address in specified DMP bank
	I2C_write_reg(I2C1, MPU6050_addr, DMP_RW_PNT, 0x06);		// Selecting memory byte 6
        
	// checking hardware revsion
	uint8_t hwRevision = I2C_read_reg(I2C1, MPU6050_addr, DMP_REG);	// Register in DMP from which to read or to which to write
	// вывод аппаратной версии MPU
	sprintf(LCD_buff, "MPU ver.:   0x%02X", hwRevision);
	LCD_pos(1, 1);
	LCD_send_string(LCD_buff);
	LCD_pos(2, 1);
	LCD_send_string("                ");
	_delay_ms(1000);
	// reset memory bank selection to 0	
	set_memory_bank(0, FALSE, FALSE);								
        
	// check OTP bank valid
	if(I2C_read_reg(I2C1, MPU6050_addr, XG_OFFS_TC) & (1<<OTP_BNK_VLD))
	{
		LCD_pos(2, 1);
		LCD_send_string("OTP bank valid  ");
		_delay_ms(1000);
	}
/*
	// set slave 0 address to 0x7F
	I2C_write_reg(I2C1, MPU6050_addr, I2C_SLV0_ADDR, 0x7F);
        
	// disable I2C Master mode
	I2C_write_bits(I2C1, MPU6050_addr, USER_CTRL, 1, I2C_MST_EN, 0);
        
	// set slave 0 address to 0x68 (self)
	I2C_write_reg(I2C1, MPU6050_addr, I2C_SLV0_ADDR, 0x68);
        
	// reset I2C Master control
	I2C_write_bits(I2C1, MPU6050_addr, USER_CTRL, 1, I2C_MST_RESET, 1);
	_delay_ms(20);
*/      
	// выбираем источник синхронизации: CLKSEL = 3 - PLL with Z Gyro reference
	I2C_write_reg(I2C1, MPU6050_addr, PWR_MGMT_1, 3<<CLKSEL);
	// Delay 100 ms for PLL to get established on x-axis gyro;
	_delay_ms(150);
	// настройка вывода прерывания:
	// - активный логический уровень на выводе INT - высокий;
	// - выход INT с открытым стоком;
	// - выход INT находится в активном состоянии до сброса прерывания;
	// - сброс прерывания только путём чтения INT_STATUS.
	I2C_write_reg(I2C1, MPU6050_addr, INT_PIN_CFG, 1<<LATCH_INT_EN);
        
	// запрет прерываний
	I2C_write_reg(I2C1, MPU6050_addr, INT_ENABLE, 0x00);
        
	// запрет записи в FIFO данных MPU (кроме DMP)
	I2C_write_reg(I2C1, MPU6050_addr, FIFO_EN, 0x00);
        
	// setting external frame sync to TEMP_OUT_L[0]
        //I2C_write_reg(I2C1, MPU6050_addr, CONFIG, 0x0A);
	I2C_write_bits(I2C1, MPU6050_addr, CONFIG, 3, EXT_SYNC_SET, TEMP_OUT_L0);
        
	// установка чувствительности акселерометра ±2g
	MPU6050_set_accel_scale();
        
	// устанавливаем чувствительность гироскопа ±2000°/сек
	MPU6050_set_gyro_scale();
        
	// установка частоты дискретизации 200 Гц
	MPU6050_set_sample_rate();
        
	// установка полосы попускания НЧ-фильтра на 42Гц
        //I2C_write_reg(I2C1, MPU6050_addr, CONFIG, 0x03);
	I2C_write_bits(I2C1, MPU6050_addr, CONFIG, 3, DLPF_CFG, DLPF);
        
	// запись программы DMP в flash-память контроллера
	if(write_memory_block(DMP2_memory, DMP2_CODE_SIZE, 0, 0, TRUE))
	{
		// print "DMP code error"
		LCD_pos(1, 1);
		LCD_send_string("DMP code:    err");
		LCD_pos(2, 1);
		LCD_send_string("                ");
		while(1);
	}
	else
	{
		// print "DMP code written"
		LCD_pos(1, 1);
		LCD_send_string("DMP code:     OK");
		LCD_pos(2, 1);
		LCD_send_string("                ");
		_delay_ms(1000);
	}
	// запись делителя скорости FIFO в прошивку DMP
	// 
	// DMP2_FIFO_RATE_DIVISOR снижает скорость FIFO 
	// в соответствии с выражением: SAMPLE_RATE / (1 + DMP2_FIFO_RATE_DIVISOR). 	
	//
	//					  [DATA]    LENGTH BANK OFFSET
	if(write_memory_block(DMP2_update, 0x02, 0x02, 0x16, TRUE))
	{
		// print "FIFO RateDiv error"
		LCD_pos(2, 1);
		LCD_send_string("FIFO RateDiv: err");
		while(1);
	}
	else
	{
		// print "FIFO RateDiv OK"
		LCD_pos(2, 1);
		LCD_send_string("FIFO RateDiv: OK");
		_delay_ms(1000);
	}
	// запись МБ начального адреса программы DMP
	I2C_write_reg(I2C1, MPU6050_addr, DMP_REG_1, 0x03);	
        
	// запись CБ начального адреса программы DMP
	I2C_write_reg(I2C1, MPU6050_addr, DMP_REG_2, 0x00);
        	
	// clear OTP Bank flag
	I2C_write_bits(I2C1, MPU6050_addr, XG_OFFS_TC, 1, OTP_BNK_VLD, 0);
        
	// set motion detection threshold to 2
	I2C_write_reg(I2C1, MPU6050_addr, MOT_THR, 2);
        
	// set zero-motion detection threshold to 156
	I2C_write_reg(I2C1, MPU6050_addr, ZMOT_THR, 156);
        
	// set motion detection duration to 80
	I2C_write_reg(I2C1, MPU6050_addr, MOT_DUR, 80);
        
	// set zero-motion detection duration to 0
	I2C_write_reg(I2C1, MPU6050_addr, ZRMOT_DUR, 0);
	
	// отключаем DMP, чтобы выполнить его сброс
	I2C_write_bits(I2C1, MPU6050_addr, USER_CTRL, 1, DMP_EN_BIT, 0);
        
	// сброс DMP:
	// - бит DMP_RESET выполняет сброс при установке его в "1", пока бит DMP_EN равен "0";
	// - бит DMP_RESET автоматически сбрасывается.
	I2C_write_bits(I2C1, MPU6050_addr, USER_CTRL, 1, DMP_RESET, 1);
        
	// разрешение FIFO
	I2C_write_bits(I2C1, MPU6050_addr, USER_CTRL, 1, FIFO_EN_BIT, 1);
        
	// сброс FIFO
	I2C_write_bits(I2C1, MPU6050_addr, USER_CTRL, 1, FIFO_RESET, 1);
        
	// set DMP and FIFO_OFLOW interrupts enabled
	I2C_write_reg(I2C1, MPU6050_addr, INT_ENABLE, 1<<FIFO_OFLOW_EN | 1<<DMP_INT_EN);
        
	// чтение регистра INT_STATUS для сброса флагов
	I2C_read_reg(I2C1, MPU6050_addr, INT_STATUS);
	// установка буфера пакетов DMP, равным 42-байта (MotionApps v2)
	DMP_packet_size = 42;

	LCD_pos(1, 1);
	LCD_send_string("DMP init.:    OK");
	LCD_pos(2, 1);
	LCD_send_string("                ");
	_delay_ms(1000);
	return;
}

//=========================================================================
// Инициализация DMP MotionApp_v6
void DMP6_init(void)
{
	// сброс выполнен при калибровке...
	
	// получение аппаратной версии MPU
	set_memory_bank(0x10, TRUE, TRUE);				// Selecting user bank 16
	// set start address in specified DMP bank
	I2C_write_reg(I2C1, MPU6050_addr, DMP_RW_PNT, 0x06);		// Selecting memory byte 6
        
	// checking hardware revsion
	uint8_t hwRevision = I2C_read_reg(I2C1, MPU6050_addr, DMP_REG);	// Register in DMP from which to read or to which to write
	// вывод аппаратной версии MPU
	sprintf(LCD_buff, "MPU ver.:   0x%02X", hwRevision);
	LCD_pos(1, 1);
	LCD_send_string(LCD_buff);
	LCD_pos(2, 1);
	LCD_send_string("                ");
	_delay_ms(1000);
	// reset memory bank selection to 0	
	set_memory_bank(0, FALSE, FALSE);								

	// выбираем источник синхронизации: CLKSEL = 1 - PLL with X Gyro reference
        
	I2C_write_reg(I2C1, MPU6050_addr, PWR_MGMT_1, 1<<CLKSEL);
	// Delay 100 ms for PLL to get established on x-axis gyro;
	_delay_ms(150);
	// настройка вывода прерывания:
	// - активный логический уровень на выводе INT - высокий;
	// - выход INT с открытым стоком;
	// - выход INT находится в активном состоянии до сброса прерывания;
	// - сброс прерывания только путём чтения INT_STATUS.
	I2C_write_reg(I2C1, MPU6050_addr, INT_PIN_CFG, 1<<LATCH_INT_EN);
        
	// запрет прерываний
	I2C_write_reg(I2C1, MPU6050_addr, INT_ENABLE, 0x00);
        
	// запрет записи в FIFO данных MPU (кроме DMP)
	I2C_write_reg(I2C1, MPU6050_addr, FIFO_EN, 0x00);
	// установка чувствительности акселерометра ±2g
	MPU6050_set_accel_scale();
	// устанавливаем чувствительность гироскопа ±2000°/сек
	MPU6050_set_gyro_scale();
	// установка частоты дискретизации 400 Гц
	MPU6050_set_sample_rate();
	// установка полосы попускания НЧ-фильтра на 188 Гц
	I2C_write_bits(I2C1, MPU6050_addr, CONFIG, 3, DLPF_CFG, DLPF);	
	
	// запись программы DMP в flash-память контроллера
	if(write_memory_block(DMP6_memory, DMP6_CODE_SIZE, 0, 0, TRUE))
	{
		// print "DMP code error"
		LCD_pos(1, 1);
		LCD_send_string("DMP code:    err");
		LCD_pos(2, 1);
		LCD_send_string("                ");
		while(1);
	}
	else
	{
		// print "DMP code written"
		LCD_pos(1, 1);
		LCD_send_string("DMP code:     OK");
		LCD_pos(2, 1);
		LCD_send_string("                ");
		_delay_ms(1000);
	}
	// запись МБ начального адреса программы DMP
	I2C_write_reg(I2C1, MPU6050_addr, DMP_REG_1, 0x04);
        
	// запись CБ начального адреса программы DMP
	I2C_write_reg(I2C1, MPU6050_addr, DMP_REG_2, 0x00);
        
	// clear OTP Bank flag
	I2C_write_bits(I2C1, MPU6050_addr, XG_OFFS_TC, 1, OTP_BNK_VLD, 0);
        
	// set motion detection threshold to 2
	I2C_write_reg(I2C1, MPU6050_addr, MOT_THR, 2);
        
	// set zero-motion detection threshold to 156
	I2C_write_reg(I2C1, MPU6050_addr, ZMOT_THR, 156);
        
	// set motion detection duration to 80
	I2C_write_reg(I2C1, MPU6050_addr, MOT_DUR, 80);
        
	// set zero-motion detection duration to 0
	I2C_write_reg(I2C1, MPU6050_addr, ZRMOT_DUR, 0);
	
	// отключаем DMP, чтобы выполнить его сброс
	I2C_write_bits(I2C1, MPU6050_addr, USER_CTRL, 1, DMP_EN_BIT, 0);
        
	// сброс DMP:
	// - бит DMP_RESET выполняет сброс при установке его в "1", пока бит DMP_EN равен "0";
	// - бит DMP_RESET автоматически сбрасывается.
	I2C_write_bits(I2C1, MPU6050_addr, USER_CTRL, 1, DMP_RESET, 1);
	// разрешение FIFO
	I2C_write_bits(I2C1, MPU6050_addr, USER_CTRL, 1, FIFO_EN_BIT, 1);
	// сброс FIFO
	I2C_write_bits(I2C1, MPU6050_addr, USER_CTRL, 1, FIFO_RESET, 1);
	// set DMP and FIFO_OFLOW interrupts enabled
	I2C_write_reg(I2C1, MPU6050_addr, INT_ENABLE, 1<<FIFO_OFLOW_EN|1<<DMP_INT_EN);
	// чтение регистра INT_STATUS для сброса флагов
	I2C_read_reg(I2C1, MPU6050_addr, INT_STATUS);
	// установка буфера пакетов DMP, равным 28-байт (MotionApps v6)
	DMP_packet_size = 28;

	LCD_pos(1, 1);
	LCD_send_string("DMP init.:    OK");
	LCD_pos(2, 1);
	LCD_send_string("                ");
	_delay_ms(1000);
}

//=========================================================================
// выбор банка памяти
void set_memory_bank(uint8_t bank, uint8_t prefetchEnabled, uint8_t userBank)
 {
	 bank &= 0x1F;
	 if(userBank) bank |= 0x20;
	 if(prefetchEnabled) bank |= 0x40;
	 I2C_write_reg(I2C1, MPU6050_addr, DMP_BANK, bank);
	 return;
 }

//=========================================================================
// запись блока памяти
uint8_t write_memory_block(const uint8_t* data, uint16_t dataSize, uint8_t bank, uint8_t addr, uint8_t verify)
{
	set_memory_bank(bank, FALSE, FALSE);
	// устанавливаем адрес для записи 0-го байта в DMP банк
	I2C_write_reg(I2C1, MPU6050_addr, DMP_RW_PNT, addr);
	for(uint16_t i = 0; i < dataSize; i++)
	{
		// загружаем i-й байт из массива flash-памяти 
		uint8_t byte = data[i];
		// записываем i-й байт в DMP банк
		I2C_write_reg(I2C1, MPU6050_addr, DMP_REG, byte);
		// проверка записи
		if(verify)
		{
			set_memory_bank(bank, FALSE, FALSE);
			// устанавливаем адрес i-го байта в DMP банке
			I2C_write_reg(I2C1, MPU6050_addr, DMP_RW_PNT, addr);
			uint8_t result = I2C_read_reg(I2C1, MPU6050_addr, DMP_REG);
			if(result != byte) return 1;
		}
		// после записи в банк 256-и байт переходим к следующему банку
		if(addr == 255)
		{
			addr = 0;
			bank++;
			set_memory_bank(bank, FALSE, FALSE);
		}
		else addr++;
		// устанавливаем адрес для записи i-го байта в DMP банк
		I2C_write_reg(I2C1, MPU6050_addr, DMP_RW_PNT, addr);
	}
	return 0;
}

//=========================================================================
// получение кватернионов (16 бит)
void DMP2_get_quat_16(float* q)
{
	uint8_t data[16];
	// читаем 42/28 (DMP_packet_size) байта из FIFO в массив data[]
	// ... для ускоррения процесса читаем только первые 16 байт...
	I2C_read_regs(I2C1, MPU6050_addr, FIFO_R_W, data, 16);
	q[0] = (int16_t)(data[0]<<8 | data[1]) / 16384.f;
	q[1] = (int16_t)(data[4]<<8 | data[5]) / 16384.f;
	q[2] = (int16_t)(data[8]<<8 | data[9]) / 16384.f;
	q[3] = (int16_t)(data[12]<<8 | data[13]) / 16384.f;
	return;
}

//=========================================================================
// получение кватернионов (32 бита)
void DMP2_get_quat_32(float* q)
{
	uint8_t data[16];
	// читаем 42/28 (DMP_packet_size) байта из FIFO в массив data[]
	// ... для ускоррения процесса читаем только первые 16 байт...
	I2C_read_regs(I2C1, MPU6050_addr, FIFO_R_W, data, 16);
	q[0] = ((uint32_t)data[0]<<24 | (uint32_t)data[1]<<16 | (uint32_t)data[2]<<8 | data[3]) / 16384.f;
	q[1] = ((uint32_t)data[4]<<24 | (uint32_t)data[5]<<16 | (uint32_t)data[6]<<8 | data[7]) / 16384.f;
	q[2] = ((uint32_t)data[8]<<24 | (uint32_t)data[9]<<16 | (uint32_t)data[10]<<8 | data[11]) / 16384.f;
	q[3] = ((uint32_t)data[12]<<24 | (uint32_t)data[13]<<16 | (uint32_t)data[14]<<8 | data[15]) / 16384.f;
	return;
}

//=========================================================================
// преобразование кватернионов в углы Эйлера
void DMP2_get_euler(float* e, float* q) 
{
	e[0] = atan2(2*q[1]*q[2] - 2*q[0]*q[3], 2*q[0]*q[0] + 2*q[1]*q[1] - 1);		// psi	
	e[1] = -asin(2*q[1]*q[3] + 2*q[0]*q[2]);					// theta													
	e[2] = atan2(2*q[2]*q[3] - 2*q[0]*q[1], 2*q[0]*q[0] + 2*q[3]*q[3] - 1);		// phi	
	return;
}

//=========================================================================
// преобразование кватернионов в проекции вектора силы тяжести G
void DMP2_get_gravity(float* g, float* q) 
{
	g[0] = 2 * (q[1]*q[3] - q[0]*q[2]);
	g[1] = 2 * (q[0]*q[1] + q[2]*q[3]);
	g[2] = q[0]*q[0] - q[1]*q[1] - q[2]*q[2] + q[3]*q[3];
	return;
}


//================================================================================================|
// Default MotionApps v2.0 42-byte FIFO packet structure:                                         |
//------------------------------------------------------------------------------------------------|
// [QUAT W][     ][QUAT X][     ][QUAT Y][      ][QUAT Z][      ][GYRO X][      ][GYRO Y][      ] |
//   0   1  2   3   4   5  6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  |
//------------------------------------------------------------------------------------------------|
// [GYRO Z][      ][ACC X ][      ][ACC Y ][      ][ACC Z ][      ][      ]                       |
//  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41                        |
//================================================================================================|    

const uint8_t DMP2_memory[DMP2_CODE_SIZE] @ "FLASH" = {
// bank 0, 256 bytes
0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCB, 0x47, 0xA2, 0x20, 0x00, 0x00, 0x00,
0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,

// bank 1, 256 bytes
0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x09, 0x23, 0xA1, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
0x80, 0x00, 0xFF, 0xFF, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,

// bank 2, 256 bytes
0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x01, 0x00, 0x05, 0x8B, 0xC1, 0x00, 0x00, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

// bank 3, 256 bytes
0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0x4C, 0xCD, 0x6C, 0xA9, 0x0C,
0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,

// bank 4, 256 bytes
0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,

// bank 5, 256 bytes
0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,

// bank 6, 256 bytes
0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,

// bank 7, 138 bytes
0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
0xDD, 0xF1, 0x20, 0x28, 0x30, 0x38, 0x9A, 0xF1, 0x28, 0x30, 0x38, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0x28, 0x30, 0x38,
0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0x30, 0xDC,
0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xFE, 0xD8, 0xFF};

//=========================================================================
// настройка делителя FIFO
const uint8_t DMP2_update[2] @ "FLASH" = {0x00, DMP2_FIFO_RATE_DIVISOR};
	
	
//==================================================================|
// Default MotionApps v6.12 28-byte FIFO packet structure:          |
//------------------------------------------------------------------|
// [QUAT W][      ][QUAT X][      ][QUAT Y][      ][QUAT Z][      ] |
//   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  |
//------------------------------------------------------------------|
// [GYRO X][GYRO Y][GYRO Z][ACC X ][ACC Y ][ACC Z ]					|
//  16  17  18  19  20  21  22  23  24  25  26  27					|
//==================================================================|

const uint8_t DMP6_memory[DMP6_CODE_SIZE] @ "FLASH" = {
// bank 0, 256 bytes
0x00, 0xF8, 0xF6, 0x2A, 0x3F, 0x68, 0xF5, 0x7A, 0x00, 0x06, 0xFF, 0xFE, 0x00, 0x03, 0x00, 0x00,
0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
0x03, 0x0C, 0x30, 0xC3, 0x0A, 0x74, 0x56, 0x2D, 0x0D, 0x62, 0xDB, 0xC7, 0x16, 0xF4, 0xBA, 0x02,
0x38, 0x83, 0xF8, 0x83, 0x30, 0x00, 0xF8, 0x83, 0x25, 0x8E, 0xF8, 0x83, 0x30, 0x00, 0xF8, 0x83,
0xFF, 0xFF, 0xFF, 0xFF, 0x0C, 0xBD, 0xD8, 0x11, 0x24, 0x00, 0x04, 0x00, 0x1A, 0x82, 0x79, 0xA1,
0x00, 0x36, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x38, 0x83, 0x6F, 0xA2,
0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
0x1F, 0xA4, 0xE8, 0xE4, 0xFF, 0xF5, 0xDC, 0xB9, 0x00, 0x5B, 0x79, 0xCF, 0x1F, 0x3F, 0x78, 0x76,
0x00, 0x86, 0x7C, 0x5A, 0x00, 0x86, 0x23, 0x47, 0xFA, 0xB9, 0x86, 0x31, 0x00, 0x74, 0x87, 0x8A,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x05, 0xFF, 0xFF, 0xE9, 0xA8, 0x00, 0x00, 0x21, 0x82,
0xFA, 0xB8, 0x4D, 0x46, 0xFF, 0xFA, 0xDF, 0x3D, 0xFF, 0xFF, 0xB2, 0xB3, 0x00, 0x00, 0x00, 0x00,
0x3F, 0xFF, 0xBA, 0x98, 0x00, 0x5D, 0xAC, 0x08, 0x00, 0x0A, 0x63, 0x78, 0x00, 0x01, 0x46, 0x21,
0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x42, 0xB5, 0x00, 0x06, 0x00, 0x64, 0x00, 0x64, 0x00, 0x06,
0x14, 0x06, 0x02, 0x9F, 0x0F, 0x47, 0x91, 0x32, 0xD9, 0x0E, 0x9F, 0xC9, 0x1D, 0xCF, 0x4C, 0x34,
0x3B, 0xB6, 0x7A, 0xE8, 0x00, 0x64, 0x00, 0x06, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE,

// bank 1, 256 bytes
0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x07, 0x00, 0x00, 0xFF, 0xF1, 0x00, 0x00, 0xFA, 0x46, 0x00, 0x00, 0xA2, 0xB8, 0x00, 0x00,
0x10, 0x00, 0x00, 0x00, 0x04, 0xD6, 0x00, 0x00, 0x04, 0xCC, 0x00, 0x00, 0x04, 0xCC, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x06, 0x00, 0x02, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x05, 0x00, 0x64, 0x00, 0x20, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x03, 0x00,
0x00, 0x00, 0x00, 0x32, 0xF8, 0x98, 0x00, 0x00, 0xFF, 0x65, 0x00, 0x00, 0x83, 0x0F, 0x00, 0x00,
0x00, 0x06, 0x00, 0x00, 0xFF, 0xF1, 0x00, 0x00, 0xFA, 0x46, 0x00, 0x00, 0xA2, 0xB8, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x02, 0x00, 0x00,
0x00, 0x01, 0xFB, 0x83, 0x00, 0x7C, 0x00, 0x00, 0xFB, 0x15, 0xFC, 0x00, 0x1F, 0xB4, 0xFF, 0x83,
0x00, 0x00, 0x00, 0x01, 0x00, 0x65, 0x00, 0x07, 0x00, 0x64, 0x03, 0xE8, 0x00, 0x64, 0x00, 0x28,
0x00, 0x00, 0xFF, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x16, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x10, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF4, 0x00, 0x00, 0x10, 0x00,

// bank 2, 256 bytes
0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x01, 0x00, 0x05, 0xBA, 0xC6, 0x00, 0x47, 0x78, 0xA2,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
0x00, 0x00, 0x23, 0xBB, 0x00, 0x2E, 0xA2, 0x5B, 0x00, 0x00, 0x05, 0x68, 0x00, 0x0B, 0xCF, 0x49,
0x00, 0x04, 0xFF, 0xFD, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x64, 0x00, 0x07, 0x00, 0x08, 0x00, 0x06, 0x00, 0x06, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x2E, 0xA2, 0x5B, 0x00, 0x00, 0x05, 0x68, 0x00, 0x0B, 0xCF, 0x49, 0x00, 0x00, 0x00, 0x00,
0x00, 0xF8, 0xF6, 0x2A, 0x3F, 0x68, 0xF5, 0x7A, 0x00, 0x04, 0xFF, 0xFD, 0x00, 0x02, 0x00, 0x00,
0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x0E,
0xFF, 0xFF, 0xFF, 0xCF, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0xFF, 0xFF, 0xFF, 0x9C,
0x00, 0x00, 0x43, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x64,
0xFF, 0xE5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

// bank 3, 256 bytes
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x24, 0x26, 0xD3,
0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 0x96, 0x00, 0x3C,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x9E, 0x65, 0x5D,
0x0C, 0x0A, 0x4E, 0x68, 0xCD, 0xCF, 0x77, 0x09, 0x50, 0x16, 0x67, 0x59, 0xC6, 0x19, 0xCE, 0x82,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x71, 0x1C,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xD7, 0x84, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x11, 0xDC, 0x47, 0x03, 0x00, 0x00, 0x00, 0xC7, 0x93, 0x8F, 0x9D, 0x1E, 0x1B, 0x1C, 0x19,
0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xDF, 0xA4, 0x38, 0x1F, 0x9E, 0x65, 0x5D,
0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x71, 0x1C, 0x02, 0x03, 0x18, 0x85, 0x00, 0x00, 0x40, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x3F, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF4, 0xC9, 0xFF, 0xFF, 0xBC, 0xF0, 0x00, 0x01, 0x0C, 0x0F,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xF5, 0xB7, 0xBA, 0xB3, 0x67, 0x7D, 0xDF, 0x7E, 0x72, 0x90, 0x2E, 0x55, 0x4C, 0xF6, 0xE6, 0x88,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

// bank 4, 256 bytes
0xD8, 0xDC, 0xB4, 0xB8, 0xB0, 0xD8, 0xB9, 0xAB, 0xF3, 0xF8, 0xFA, 0xB3, 0xB7, 0xBB, 0x8E, 0x9E,
0xAE, 0xF1, 0x32, 0xF5, 0x1B, 0xF1, 0xB4, 0xB8, 0xB0, 0x80, 0x97, 0xF1, 0xA9, 0xDF, 0xDF, 0xDF,
0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0x4C, 0xCD, 0x6C, 0xA9, 0x0C, 0xC9, 0x2C, 0x97, 0xF1, 0xA9,
0x89, 0x26, 0x46, 0x66, 0xB2, 0x89, 0x99, 0xA9, 0x2D, 0x55, 0x7D, 0xB0, 0xB0, 0x8A, 0xA8, 0x96,
0x36, 0x56, 0x76, 0xF1, 0xBA, 0xA3, 0xB4, 0xB2, 0x80, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB2, 0x83,
0x98, 0xBA, 0xA3, 0xF0, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xB2, 0xB9, 0xB4, 0x98, 0x83, 0xF1,
0xA3, 0x29, 0x55, 0x7D, 0xBA, 0xB5, 0xB1, 0xA3, 0x83, 0x93, 0xF0, 0x00, 0x28, 0x50, 0xF5, 0xB2,
0xB6, 0xAA, 0x83, 0x93, 0x28, 0x54, 0x7C, 0xF1, 0xB9, 0xA3, 0x82, 0x93, 0x61, 0xBA, 0xA2, 0xDA,
0xDE, 0xDF, 0xDB, 0x81, 0x9A, 0xB9, 0xAE, 0xF5, 0x60, 0x68, 0x70, 0xF1, 0xDA, 0xBA, 0xA2, 0xDF,
0xD9, 0xBA, 0xA2, 0xFA, 0xB9, 0xA3, 0x82, 0x92, 0xDB, 0x31, 0xBA, 0xA2, 0xD9, 0xBA, 0xA2, 0xF8,
0xDF, 0x85, 0xA4, 0xD0, 0xC1, 0xBB, 0xAD, 0x83, 0xC2, 0xC5, 0xC7, 0xB8, 0xA2, 0xDF, 0xDF, 0xDF,
0xBA, 0xA0, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xAA, 0xB3, 0x8D, 0xB4, 0x98, 0x0D, 0x35,
0x5D, 0xB2, 0xB6, 0xBA, 0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A,
0xB8, 0xAA, 0x87, 0x2C, 0x54, 0x7C, 0xBA, 0xA4, 0xB0, 0x8A, 0xB6, 0x91, 0x32, 0x56, 0x76, 0xB2,
0x84, 0x94, 0xA4, 0xC8, 0x08, 0xCD, 0xD8, 0xB8, 0xB4, 0xB0, 0xF1, 0x99, 0x82, 0xA8, 0x2D, 0x55,
0x7D, 0x98, 0xA8, 0x0E, 0x16, 0x1E, 0xA2, 0x2C, 0x54, 0x7C, 0x92, 0xA4, 0xF0, 0x2C, 0x50, 0x78,

// bank 5, 256 bytes
0xF1, 0x84, 0xA8, 0x98, 0xC4, 0xCD, 0xFC, 0xD8, 0x0D, 0xDB, 0xA8, 0xFC, 0x2D, 0xF3, 0xD9, 0xBA,
0xA6, 0xF8, 0xDA, 0xBA, 0xA6, 0xDE, 0xD8, 0xBA, 0xB2, 0xB6, 0x86, 0x96, 0xA6, 0xD0, 0xF3, 0xC8,
0x41, 0xDA, 0xA6, 0xC8, 0xF8, 0xD8, 0xB0, 0xB4, 0xB8, 0x82, 0xA8, 0x92, 0xF5, 0x2C, 0x54, 0x88,
0x98, 0xF1, 0x35, 0xD9, 0xF4, 0x18, 0xD8, 0xF1, 0xA2, 0xD0, 0xF8, 0xF9, 0xA8, 0x84, 0xD9, 0xC7,
0xDF, 0xF8, 0xF8, 0x83, 0xC5, 0xDA, 0xDF, 0x69, 0xDF, 0x83, 0xC1, 0xD8, 0xF4, 0x01, 0x14, 0xF1,
0xA8, 0x82, 0x4E, 0xA8, 0x84, 0xF3, 0x11, 0xD1, 0x82, 0xF5, 0xD9, 0x92, 0x28, 0x97, 0x88, 0xF1,
0x09, 0xF4, 0x1C, 0x1C, 0xD8, 0x84, 0xA8, 0xF3, 0xC0, 0xF9, 0xD1, 0xD9, 0x97, 0x82, 0xF1, 0x29,
0xF4, 0x0D, 0xD8, 0xF3, 0xF9, 0xF9, 0xD1, 0xD9, 0x82, 0xF4, 0xC2, 0x03, 0xD8, 0xDE, 0xDF, 0x1A,
0xD8, 0xF1, 0xA2, 0xFA, 0xF9, 0xA8, 0x84, 0x98, 0xD9, 0xC7, 0xDF, 0xF8, 0xF8, 0xF8, 0x83, 0xC7,
0xDA, 0xDF, 0x69, 0xDF, 0xF8, 0x83, 0xC3, 0xD8, 0xF4, 0x01, 0x14, 0xF1, 0x98, 0xA8, 0x82, 0x2E,
0xA8, 0x84, 0xF3, 0x11, 0xD1, 0x82, 0xF5, 0xD9, 0x92, 0x50, 0x97, 0x88, 0xF1, 0x09, 0xF4, 0x1C,
0xD8, 0x84, 0xA8, 0xF3, 0xC0, 0xF8, 0xF9, 0xD1, 0xD9, 0x97, 0x82, 0xF1, 0x49, 0xF4, 0x0D, 0xD8,
0xF3, 0xF9, 0xF9, 0xD1, 0xD9, 0x82, 0xF4, 0xC4, 0x03, 0xD8, 0xDE, 0xDF, 0xD8, 0xF1, 0xAD, 0x88,
0x98, 0xCC, 0xA8, 0x09, 0xF9, 0xD9, 0x82, 0x92, 0xA8, 0xF5, 0x7C, 0xF1, 0x88, 0x3A, 0xCF, 0x94,
0x4A, 0x6E, 0x98, 0xDB, 0x69, 0x31, 0xDA, 0xAD, 0xF2, 0xDE, 0xF9, 0xD8, 0x87, 0x95, 0xA8, 0xF2,
0x21, 0xD1, 0xDA, 0xA5, 0xF9, 0xF4, 0x17, 0xD9, 0xF1, 0xAE, 0x8E, 0xD0, 0xC0, 0xC3, 0xAE, 0x82,

// bank 6, 256 bytes
0xC6, 0x84, 0xC3, 0xA8, 0x85, 0x95, 0xC8, 0xA5, 0x88, 0xF2, 0xC0, 0xF1, 0xF4, 0x01, 0x0E, 0xF1,
0x8E, 0x9E, 0xA8, 0xC6, 0x3E, 0x56, 0xF5, 0x54, 0xF1, 0x88, 0x72, 0xF4, 0x01, 0x15, 0xF1, 0x98,
0x45, 0x85, 0x6E, 0xF5, 0x8E, 0x9E, 0x04, 0x88, 0xF1, 0x42, 0x98, 0x5A, 0x8E, 0x9E, 0x06, 0x88,
0x69, 0xF4, 0x01, 0x1C, 0xF1, 0x98, 0x1E, 0x11, 0x08, 0xD0, 0xF5, 0x04, 0xF1, 0x1E, 0x97, 0x02,
0x02, 0x98, 0x36, 0x25, 0xDB, 0xF9, 0xD9, 0x85, 0xA5, 0xF3, 0xC1, 0xDA, 0x85, 0xA5, 0xF3, 0xDF,
0xD8, 0x85, 0x95, 0xA8, 0xF3, 0x09, 0xDA, 0xA5, 0xFA, 0xD8, 0x82, 0x92, 0xA8, 0xF5, 0x78, 0xF1,
0x88, 0x1A, 0x84, 0x9F, 0x26, 0x88, 0x98, 0x21, 0xDA, 0xF4, 0x1D, 0xF3, 0xD8, 0x87, 0x9F, 0x39,
0xD1, 0xAF, 0xD9, 0xDF, 0xDF, 0xFB, 0xF9, 0xF4, 0x0C, 0xF3, 0xD8, 0xFA, 0xD0, 0xF8, 0xDA, 0xF9,
0xF9, 0xD0, 0xDF, 0xD9, 0xF9, 0xD8, 0xF4, 0x0B, 0xD8, 0xF3, 0x87, 0x9F, 0x39, 0xD1, 0xAF, 0xD9,
0xDF, 0xDF, 0xF4, 0x1D, 0xF3, 0xD8, 0xFA, 0xFC, 0xA8, 0x69, 0xF9, 0xF9, 0xAF, 0xD0, 0xDA, 0xDE,
0xFA, 0xD9, 0xF8, 0x8F, 0x9F, 0xA8, 0xF1, 0xCC, 0xF3, 0x98, 0xDB, 0x45, 0xD9, 0xAF, 0xDF, 0xD0,
0xF8, 0xD8, 0xF1, 0x8F, 0x9F, 0xA8, 0xCA, 0xF3, 0x88, 0x09, 0xDA, 0xAF, 0x8F, 0xCB, 0xF8, 0xD8,
0xF2, 0xAD, 0x97, 0x8D, 0x0C, 0xD9, 0xA5, 0xDF, 0xF9, 0xBA, 0xA6, 0xF3, 0xFA, 0xF4, 0x12, 0xF2,
0xD8, 0x95, 0x0D, 0xD1, 0xD9, 0xBA, 0xA6, 0xF3, 0xFA, 0xDA, 0xA5, 0xF2, 0xC1, 0xBA, 0xA6, 0xF3,
0xDF, 0xD8, 0xF1, 0xBA, 0xB2, 0xB6, 0x86, 0x96, 0xA6, 0xD0, 0xCA, 0xF3, 0x49, 0xDA, 0xA6, 0xCB,
0xF8, 0xD8, 0xB0, 0xB4, 0xB8, 0xD8, 0xAD, 0x84, 0xF2, 0xC0, 0xDF, 0xF1, 0x8F, 0xCB, 0xC3, 0xA8,

// bank 7, 256 bytes
0xB2, 0xB6, 0x86, 0x96, 0xC8, 0xC1, 0xCB, 0xC3, 0xF3, 0xB0, 0xB4, 0x88, 0x98, 0xA8, 0x21, 0xDB,
0x71, 0x8D, 0x9D, 0x71, 0x85, 0x95, 0x21, 0xD9, 0xAD, 0xF2, 0xFA, 0xD8, 0x85, 0x97, 0xA8, 0x28,
0xD9, 0xF4, 0x08, 0xD8, 0xF2, 0x8D, 0x29, 0xDA, 0xF4, 0x05, 0xD9, 0xF2, 0x85, 0xA4, 0xC2, 0xF2,
0xD8, 0xA8, 0x8D, 0x94, 0x01, 0xD1, 0xD9, 0xF4, 0x11, 0xF2, 0xD8, 0x87, 0x21, 0xD8, 0xF4, 0x0A,
0xD8, 0xF2, 0x84, 0x98, 0xA8, 0xC8, 0x01, 0xD1, 0xD9, 0xF4, 0x11, 0xD8, 0xF3, 0xA4, 0xC8, 0xBB,
0xAF, 0xD0, 0xF2, 0xDE, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xD8, 0xF1, 0xB8, 0xF6,
0xB5, 0xB9, 0xB0, 0x8A, 0x95, 0xA3, 0xDE, 0x3C, 0xA3, 0xD9, 0xF8, 0xD8, 0x5C, 0xA3, 0xD9, 0xF8,
0xD8, 0x7C, 0xA3, 0xD9, 0xF8, 0xD8, 0xF8, 0xF9, 0xD1, 0xA5, 0xD9, 0xDF, 0xDA, 0xFA, 0xD8, 0xB1,
0x85, 0x30, 0xF7, 0xD9, 0xDE, 0xD8, 0xF8, 0x30, 0xAD, 0xDA, 0xDE, 0xD8, 0xF2, 0xB4, 0x8C, 0x99,
0xA3, 0x2D, 0x55, 0x7D, 0xA0, 0x83, 0xDF, 0xDF, 0xDF, 0xB5, 0x91, 0xA0, 0xF6, 0x29, 0xD9, 0xFB,
0xD8, 0xA0, 0xFC, 0x29, 0xD9, 0xFA, 0xD8, 0xA0, 0xD0, 0x51, 0xD9, 0xF8, 0xD8, 0xFC, 0x51, 0xD9,
0xF9, 0xD8, 0x79, 0xD9, 0xFB, 0xD8, 0xA0, 0xD0, 0xFC, 0x79, 0xD9, 0xFA, 0xD8, 0xA1, 0xF9, 0xF9,
0xF9, 0xF9, 0xF9, 0xA0, 0xDA, 0xDF, 0xDF, 0xDF, 0xD8, 0xA1, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xAC,
0xDE, 0xF8, 0xAD, 0xDE, 0x83, 0x93, 0xAC, 0x2C, 0x54, 0x7C, 0xF1, 0xA8, 0xDF, 0xDF, 0xDF, 0xF6,
0x9D, 0x2C, 0xDA, 0xA0, 0xDF, 0xD9, 0xFA, 0xDB, 0x2D, 0xF8, 0xD8, 0xA8, 0x50, 0xDA, 0xA0, 0xD0,
0xDE, 0xD9, 0xD0, 0xF8, 0xF8, 0xF8, 0xDB, 0x55, 0xF8, 0xD8, 0xA8, 0x78, 0xDA, 0xA0, 0xD0, 0xDF,

// bank 8, 256 bytes
0xD9, 0xD0, 0xFA, 0xF8, 0xF8, 0xF8, 0xF8, 0xDB, 0x7D, 0xF8, 0xD8, 0x9C, 0xA8, 0x8C, 0xF5, 0x30,
0xDB, 0x38, 0xD9, 0xD0, 0xDE, 0xDF, 0xA0, 0xD0, 0xDE, 0xDF, 0xD8, 0xA8, 0x48, 0xDB, 0x58, 0xD9,
0xDF, 0xD0, 0xDE, 0xA0, 0xDF, 0xD0, 0xDE, 0xD8, 0xA8, 0x68, 0xDB, 0x70, 0xD9, 0xDF, 0xDF, 0xA0,
0xDF, 0xDF, 0xD8, 0xF1, 0xA8, 0x88, 0x90, 0x2C, 0x54, 0x7C, 0x98, 0xA8, 0xD0, 0x5C, 0x38, 0xD1,
0xDA, 0xF2, 0xAE, 0x8C, 0xDF, 0xF9, 0xD8, 0xB0, 0x87, 0xA8, 0xC1, 0xC1, 0xB1, 0x88, 0xA8, 0xC6,
0xF9, 0xF9, 0xDA, 0x36, 0xD8, 0xA8, 0xF9, 0xDA, 0x36, 0xD8, 0xA8, 0xF9, 0xDA, 0x36, 0xD8, 0xA8,
0xF9, 0xDA, 0x36, 0xD8, 0xA8, 0xF9, 0xDA, 0x36, 0xD8, 0xF7, 0x8D, 0x9D, 0xAD, 0xF8, 0x18, 0xDA,
0xF2, 0xAE, 0xDF, 0xD8, 0xF7, 0xAD, 0xFA, 0x30, 0xD9, 0xA4, 0xDE, 0xF9, 0xD8, 0xF2, 0xAE, 0xDE,
0xFA, 0xF9, 0x83, 0xA7, 0xD9, 0xC3, 0xC5, 0xC7, 0xF1, 0x88, 0x9B, 0xA7, 0x7A, 0xAD, 0xF7, 0xDE,
0xDF, 0xA4, 0xF8, 0x84, 0x94, 0x08, 0xA7, 0x97, 0xF3, 0x00, 0xAE, 0xF2, 0x98, 0x19, 0xA4, 0x88,
0xC6, 0xA3, 0x94, 0x88, 0xF6, 0x32, 0xDF, 0xF2, 0x83, 0x93, 0xDB, 0x09, 0xD9, 0xF2, 0xAA, 0xDF,
0xD8, 0xD8, 0xAE, 0xF8, 0xF9, 0xD1, 0xDA, 0xF3, 0xA4, 0xDE, 0xA7, 0xF1, 0x88, 0x9B, 0x7A, 0xD8,
0xF3, 0x84, 0x94, 0xAE, 0x19, 0xF9, 0xDA, 0xAA, 0xF1, 0xDF, 0xD8, 0xA8, 0x81, 0xC0, 0xC3, 0xC5,
0xC7, 0xA3, 0x92, 0x83, 0xF6, 0x28, 0xAD, 0xDE, 0xD9, 0xF8, 0xD8, 0xA3, 0x50, 0xAD, 0xD9, 0xF8,
0xD8, 0xA3, 0x78, 0xAD, 0xD9, 0xF8, 0xD8, 0xF8, 0xF9, 0xD1, 0xA1, 0xDA, 0xDE, 0xC3, 0xC5, 0xC7,
0xD8, 0xA1, 0x81, 0x94, 0xF8, 0x18, 0xF2, 0xB0, 0x89, 0xAC, 0xC3, 0xC5, 0xC7, 0xF1, 0xD8, 0xB8,

// bank 9, 256 bytes
0xB4, 0xB0, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97, 0x28, 0x88, 0x9B, 0xF0,
0x0C, 0x20, 0x14, 0x40, 0xB0, 0xB4, 0xB8, 0xF0, 0xA8, 0x8A, 0x9A, 0x28, 0x50, 0x78, 0xB7, 0x9B,
0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31, 0xF1, 0xBB, 0xAB,
0x88, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0xB3, 0x8B, 0xB8, 0xA8, 0x04, 0x28, 0x50, 0x78, 0xF1, 0xB0,
0x88, 0xB4, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xBB, 0xAB, 0xB3, 0x8B, 0x02, 0x26, 0x46, 0x66, 0xB0,
0xB8, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79, 0x8A, 0x24, 0x70, 0x59,
0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68, 0x8A, 0x64, 0x48, 0x31,
0x8B, 0x30, 0x49, 0x60, 0x88, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04, 0x28,
0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66, 0xF0,
0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31, 0xA9,
0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60, 0x8C,
0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76, 0x7E,
0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0xD8, 0xB1, 0xB5, 0xB9, 0xA3, 0xDF, 0xDF, 0xDF, 0xAE, 0xD0,
0xDF, 0xAA, 0xD0, 0xDE, 0xF2, 0xAB, 0xF8, 0xF9, 0xD9, 0xB0, 0x87, 0xC4, 0xAA, 0xF1, 0xDF, 0xDF,
0xBB, 0xAF, 0xDF, 0xDF, 0xB9, 0xD8, 0xB1, 0xF1, 0xA3, 0x97, 0x8E, 0x60, 0xDF, 0xB0, 0x84, 0xF2,
0xC8, 0xF8, 0xF9, 0xD9, 0xDE, 0xD8, 0x93, 0x85, 0xF1, 0x4A, 0xB1, 0x83, 0xA3, 0x08, 0xB5, 0x83,

// bank 10, 256 bytes
0x9A, 0x08, 0x10, 0xB7, 0x9F, 0x10, 0xD8, 0xF1, 0xB0, 0xBA, 0xAE, 0xB0, 0x8A, 0xC2, 0xB2, 0xB6,
0x8E, 0x9E, 0xF1, 0xFB, 0xD9, 0xF4, 0x1D, 0xD8, 0xF9, 0xD9, 0x0C, 0xF1, 0xD8, 0xF8, 0xF8, 0xAD,
0x61, 0xD9, 0xAE, 0xFB, 0xD8, 0xF4, 0x0C, 0xF1, 0xD8, 0xF8, 0xF8, 0xAD, 0x19, 0xD9, 0xAE, 0xFB,
0xDF, 0xD8, 0xF4, 0x16, 0xF1, 0xD8, 0xF8, 0xAD, 0x8D, 0x61, 0xD9, 0xF4, 0xF4, 0xAC, 0xF5, 0x9C,
0x9C, 0x8D, 0xDF, 0x2B, 0xBA, 0xB6, 0xAE, 0xFA, 0xF8, 0xF4, 0x0B, 0xD8, 0xF1, 0xAE, 0xD0, 0xF8,
0xAD, 0x51, 0xDA, 0xAE, 0xFA, 0xF8, 0xF1, 0xD8, 0xB9, 0xB1, 0xB6, 0xA3, 0x83, 0x9C, 0x08, 0xB9,
0xB1, 0x83, 0x9A, 0xB5, 0xAA, 0xC0, 0xFD, 0x30, 0x83, 0xB7, 0x9F, 0x10, 0xB5, 0x8B, 0x93, 0xF2,
0x02, 0x02, 0xD1, 0xAB, 0xDA, 0xDE, 0xD8, 0xF1, 0xB0, 0x80, 0xBA, 0xAB, 0xC0, 0xC3, 0xB2, 0x84,
0xC1, 0xC3, 0xD8, 0xB1, 0xB9, 0xF3, 0x8B, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xB0,
0x87, 0x9C, 0xB9, 0xA3, 0xDD, 0xF1, 0xB3, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0xB0, 0x87, 0x20, 0x28,
0x30, 0x38, 0xB2, 0x8B, 0xB6, 0x9B, 0xF2, 0xA3, 0xC0, 0xC8, 0xC2, 0xC4, 0xCC, 0xC6, 0xA3, 0xA3,
0xA3, 0xF1, 0xB0, 0x87, 0xB5, 0x9A, 0xD8, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC, 0xBA, 0xAC, 0xDF, 0xB9,
0xA3, 0xFE, 0xF2, 0xAB, 0xC4, 0xAA, 0xF1, 0xDF, 0xDF, 0xBB, 0xAF, 0xDF, 0xDF, 0xA3, 0xA3, 0xA3,
0xD8, 0xD8, 0xD8, 0xBB, 0xB3, 0xB7, 0xF1, 0xAA, 0xF9, 0xDA, 0xFF, 0xD9, 0x80, 0x9A, 0xAA, 0x28,
0xB4, 0x80, 0x98, 0xA7, 0x20, 0xB7, 0x97, 0x87, 0xA8, 0x66, 0x88, 0xF0, 0x79, 0x51, 0xF1, 0x90,
0x2C, 0x87, 0x0C, 0xA7, 0x81, 0x97, 0x62, 0x93, 0xF0, 0x71, 0x71, 0x60, 0x85, 0x94, 0x01, 0x29,

// bank 11, 246 bytes
0x51, 0x79, 0x90, 0xA5, 0xF1, 0x28, 0x4C, 0x6C, 0x87, 0x0C, 0x95, 0x18, 0x85, 0x78, 0xA3, 0x83,
0x90, 0x28, 0x4C, 0x6C, 0x88, 0x6C, 0xD8, 0xF3, 0xA2, 0x82, 0x00, 0xF2, 0x10, 0xA8, 0x92, 0x19,
0x80, 0xA2, 0xF2, 0xD9, 0x26, 0xD8, 0xF1, 0x88, 0xA8, 0x4D, 0xD9, 0x48, 0xD8, 0x96, 0xA8, 0x39,
0x80, 0xD9, 0x3C, 0xD8, 0x95, 0x80, 0xA8, 0x39, 0xA6, 0x86, 0x98, 0xD9, 0x2C, 0xDA, 0x87, 0xA7,
0x2C, 0xD8, 0xA8, 0x89, 0x95, 0x19, 0xA9, 0x80, 0xD9, 0x38, 0xD8, 0xA8, 0x89, 0x39, 0xA9, 0x80,
0xDA, 0x3C, 0xD8, 0xA8, 0x2E, 0xA8, 0x39, 0x90, 0xD9, 0x0C, 0xD8, 0xA8, 0x95, 0x31, 0x98, 0xD9,
0x0C, 0xD8, 0xA8, 0x09, 0xD9, 0xFF, 0xD8, 0x01, 0xDA, 0xFF, 0xD8, 0x95, 0x39, 0xA9, 0xDA, 0x26,
0xFF, 0xD8, 0x90, 0xA8, 0x0D, 0x89, 0x99, 0xA8, 0x10, 0x80, 0x98, 0x21, 0xDA, 0x2E, 0xD8, 0x89,
0x99, 0xA8, 0x31, 0x80, 0xDA, 0x2E, 0xD8, 0xA8, 0x86, 0x96, 0x31, 0x80, 0xDA, 0x2E, 0xD8, 0xA8,
0x87, 0x31, 0x80, 0xDA, 0x2E, 0xD8, 0xA8, 0x82, 0x92, 0xF3, 0x41, 0x80, 0xF1, 0xD9, 0x2E, 0xD8,
0xA8, 0x82, 0xF3, 0x19, 0x80, 0xF1, 0xD9, 0x2E, 0xD8, 0x82, 0xAC, 0xF3, 0xC0, 0xA2, 0x80, 0x22,
0xF1, 0xA6, 0x2E, 0xA7, 0x2E, 0xA9, 0x22, 0x98, 0xA8, 0x29, 0xDA, 0xAC, 0xDE, 0xFF, 0xD8, 0xA2,
0xF2, 0x2A, 0xF1, 0xA9, 0x2E, 0x82, 0x92, 0xA8, 0xF2, 0x31, 0x80, 0xA6, 0x96, 0xF1, 0xD9, 0x00,
0xAC, 0x8C, 0x9C, 0x0C, 0x30, 0xAC, 0xDE, 0xD0, 0xDE, 0xFF, 0xD8, 0x8C, 0x9C, 0xAC, 0xD0, 0x10,
0xAC, 0xDE, 0x80, 0x92, 0xA2, 0xF2, 0x4C, 0x82, 0xA8, 0xF1, 0xCA, 0xF2, 0x35, 0xF1, 0x96, 0x88,
0xA6, 0xD9, 0x00, 0xD8, 0xF1, 0xFF};
